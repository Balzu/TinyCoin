# network size
SIZE 1000

# parameters of periodic execution
CYCLES 30
CYCLE_LENGTH 1000

# parameters of message transfer
MINDELAY 0
MAXDELAY 0
DROP 0

random.seed 1234567890
network.size SIZE
network.node TinyCoinNode
simulation.endtime CYCLE_LENGTH*CYCLES
simulation.logtime CYCLE

protocol.link IdleProtocol

protocol.node it.unipi.p2p.tinycoin.NodeProtocol
protocol.node.linkable link
protocol.node.step CYCLE_LENGTH
protocol.node.transport tr
protocol.node.transaction_prob 0.2

protocol.urt UniformRandomTransport
protocol.urt.mindelay (CYCLE_LENGTH*MINDELAY)/100
protocol.urt.maxdelay (CYCLE_LENGTH*MAXDELAY)/100

protocol.tr UnreliableTransport
protocol.tr.transport urt
protocol.tr.drop DROP

protocol.miner it.unipi.p2p.tinycoin.MinerProtocol
protocol.miner.step CYCLE_LENGTH

init.0 WireKOut
init.0.protocol link
init.0.k 20

init.1 it.unipi.p2p.tinycoin.NodesInitializer
init.1.pminer 0.10
init.1.pcpu 10
init.1.pgpu 30
init.1.pfpga 30
init.1.pasic 30
init.1.max_balance 1000

init.2 CDScheduler
init.2.protocol node
init.2.randstart

control.oracle it.unipi.p2p.tinycoin.Oracle
control.oracle.prob_2_miners 0.05
control.oracle.hr_cpu 50
control.oracle.hr_gpu 1000
control.oracle.hr_fpga 800
control.oracle.hr_asic 1000000
control.oracle.miner_protocol miner
# The oracle will be called once every CICLE_LENGTH time points. In the project specification, it should follow a distribution? But how to implement?
control.oracle.step CYCLE_LENGTH	
